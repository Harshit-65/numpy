"""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
A small templating language

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
This implements a small templating language.  This language implements

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
if/elif/else, for/continue/break, expressions, and blocks of Python

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
code.  The syntax is::

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
  {{any expression (function calls etc)}}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
  {{any expression | filter}}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
  {{for x in y}}...{{endfor}}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
  {{if x}}x{{elif y}}y{{else}}z{{endif}}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
  {{py:x=1}}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
  {{py:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
  def foo(bar):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
      return 'baz'

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
  }}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
  {{default var = default_value}}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
  {{# comment}}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
You use this with the ``Template`` class or the ``sub`` shortcut.

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
The ``Template`` class takes the template string and the name of

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
the template (for errors) and a default namespace.  Then (like

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
``string.Template``) you can call the ``tmpl.substitute(**kw)``

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
method to make a substitution (or ``tmpl.substitute(a_dict)``).

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
``sub(content, **kw)`` substitutes the template immediately.  You

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
can use ``__name='tmpl.html'`` to set the name of the template.

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
If there are syntax errors ``TemplateError`` will be raised.

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
"""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
import re

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
import sys

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
import os

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
import tokenize

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
from io import StringIO

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
from ._looper import looper

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
__all__ = ["TemplateError", "Template", "sub", "bunch"]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
in_re = re.compile(r"\s+in\s+")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
var_re = re.compile(r"^[a-z_][a-z0-9_]*$", re.I)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
basestring_ = (bytes, str)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def coerce_text(v):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if not isinstance(v, basestring_):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if hasattr(v, "__str__"):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return str(v)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return bytes(v)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return v

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
class TemplateError(Exception):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    """Exception raised while parsing a template"""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __init__(self, message, position, name=None):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        Exception.__init__(self, message)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self.position = position

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self.name = name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __str__(self):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        msg = " ".join(self.args)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if self.position:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            msg = "%s at line %s column %s" % (msg, self.position[0], self.position[1])

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if self.name:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            msg += " in %s" % self.name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return msg

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
class _TemplateContinue(Exception):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    pass

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
class _TemplateBreak(Exception):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    pass

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def get_file_template(name, from_template):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    path = os.path.join(os.path.dirname(from_template.name), name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return from_template.__class__.from_filename(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        path, namespace=from_template.namespace, get_template=from_template.get_template

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
class Template:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    default_namespace = {

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        "start_braces": "{{",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        "end_braces": "}}",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        "looper": looper,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    }

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    default_encoding = "utf8"

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    default_inherit = None

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __init__(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        content,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        name=None,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        namespace=None,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        stacklevel=None,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        get_template=None,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        default_inherit=None,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        line_offset=0,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        delimiters=None,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    ):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self.content = content

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        # set delimiters

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if delimiters is None:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            delimiters = (

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                self.default_namespace["start_braces"],

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                self.default_namespace["end_braces"],

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            # assert len(delimiters) == 2 and all([isinstance(delimiter, basestring)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            #                                     for delimiter in delimiters])

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self.default_namespace = self.__class__.default_namespace.copy()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self.default_namespace["start_braces"] = delimiters[0]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self.default_namespace["end_braces"] = delimiters[1]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self.delimiters = delimiters

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self._unicode = isinstance(content, str)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if name is None and stacklevel is not None:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            try:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                caller = sys._getframe(stacklevel)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            except ValueError:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                pass

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                globals = caller.f_globals

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                lineno = caller.f_lineno

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if "__file__" in globals:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    name = globals["__file__"]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    if name.endswith((".pyc", ".pyo")):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        name = name[:-1]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                elif "__name__" in globals:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    name = globals["__name__"]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    name = "<string>"

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if lineno:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    name += ":%s" % lineno

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self.name = name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self._parsed = parse(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            content, name=name, line_offset=line_offset, delimiters=self.delimiters

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if namespace is None:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            namespace = {}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self.namespace = namespace

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self.get_template = get_template

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if default_inherit is not None:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self.default_inherit = default_inherit

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    @classmethod

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def from_filename(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        cls,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        filename,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        namespace=None,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        encoding=None,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        default_inherit=None,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        get_template=get_file_template,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    ):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        with open(filename, "rb") as f:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            c = f.read()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if encoding:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            c = c.decode(encoding)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return cls(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            content=c,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            name=filename,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            namespace=namespace,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            default_inherit=default_inherit,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            get_template=get_template,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __repr__(self):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return f"<{self.__class__.__name__} {id(self):x} name={self.name!r}>"

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def substitute(self, *args, **kw):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if args:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if kw:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                raise TypeError("You can only give positional *or* keyword arguments")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if len(args) > 1:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                raise TypeError("You can only give one positional argument")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if not hasattr(args[0], "items"):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                raise TypeError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    "If you pass in a single argument, you must pass in a "

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    "dictionary-like object (with a .items() method); you gave %r"

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    % (args[0],)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            kw = args[0]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ns = kw

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ns["__template_name__"] = self.name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if self.namespace:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ns.update(self.namespace)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        result, defs, inherit = self._interpret(ns)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if not inherit:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            inherit = self.default_inherit

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if inherit:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            result = self._interpret_inherit(result, defs, inherit, ns)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return result

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def _interpret(self, ns):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        __traceback_hide__ = True

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        parts = []

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        defs = {}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self._interpret_codes(self._parsed, ns, out=parts, defs=defs)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if "__inherit__" in defs:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            inherit = defs.pop("__inherit__")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            inherit = None

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return "".join(parts), defs, inherit

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def _interpret_inherit(self, body, defs, inherit_template, ns):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        __traceback_hide__ = True

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if not self.get_template:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                "You cannot use inheritance without passing in get_template",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                position=None,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                name=self.name,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        templ = self.get_template(inherit_template, self)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self_ = TemplateObject(self.name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        for name, value in defs.items():

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            setattr(self_, name, value)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self_.body = body

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ns = ns.copy()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ns["self"] = self_

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return templ.substitute(ns)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def _interpret_codes(self, codes, ns, out, defs):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        __traceback_hide__ = True

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        for item in codes:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if isinstance(item, basestring_):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                out.append(item)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                self._interpret_code(item, ns, out, defs)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def _interpret_code(self, code, ns, out, defs):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        __traceback_hide__ = True

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        name, pos = code[0], code[1]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if name == "py":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._exec(code[2], ns, pos)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        elif name == "continue":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise _TemplateContinue()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        elif name == "break":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise _TemplateBreak()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        elif name == "for":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            vars, expr, content = code[2], code[3], code[4]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            expr = self._eval(expr, ns, pos)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._interpret_for(vars, expr, content, ns, out, defs)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        elif name == "cond":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            parts = code[2:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._interpret_if(parts, ns, out, defs)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        elif name == "expr":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            parts = code[2].split("|")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            base = self._eval(parts[0], ns, pos)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            for part in parts[1:]:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                func = self._eval(part, ns, pos)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                base = func(base)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            out.append(self._repr(base, pos))

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        elif name == "default":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            var, expr = code[2], code[3]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if var not in ns:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                result = self._eval(expr, ns, pos)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                ns[var] = result

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        elif name == "inherit":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            expr = code[2]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            value = self._eval(expr, ns, pos)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            defs["__inherit__"] = value

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        elif name == "def":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            name = code[2]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            signature = code[3]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            parts = code[4]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ns[name] = defs[name] = TemplateDef(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                self, name, signature, body=parts, ns=ns, pos=pos

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        elif name == "comment":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            assert 0, "Unknown code: %r" % name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def _interpret_for(self, vars, expr, content, ns, out, defs):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        __traceback_hide__ = True

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        for item in expr:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if len(vars) == 1:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                ns[vars[0]] = item

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if len(vars) != len(item):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    raise ValueError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        "Need %i items to unpack (got %i items)"

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        % (len(vars), len(item))

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                for name, value in zip(vars, item):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    ns[name] = value

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            try:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                self._interpret_codes(content, ns, out, defs)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            except _TemplateContinue:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                continue

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            except _TemplateBreak:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                break

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def _interpret_if(self, parts, ns, out, defs):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        __traceback_hide__ = True

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        # @@: if/else/else gets through

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        for part in parts:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            assert not isinstance(part, basestring_)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            name, pos = part[0], part[1]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if name == "else":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                result = True

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                result = self._eval(part[2], ns, pos)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if result:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                self._interpret_codes(part[3], ns, out, defs)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                break

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def _eval(self, code, ns, pos):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        __traceback_hide__ = True

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        try:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            try:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                value = eval(code, self.default_namespace, ns)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            except SyntaxError as e:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                raise SyntaxError("invalid syntax in expression: %s" % code)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return value

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        except Exception as e:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if getattr(e, "args", None):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                arg0 = e.args[0]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                arg0 = coerce_text(e)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            e.args = (self._add_line_info(arg0, pos),)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def _exec(self, code, ns, pos):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        __traceback_hide__ = True

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        try:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            exec(code, self.default_namespace, ns)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        except Exception as e:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if e.args:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                e.args = (self._add_line_info(e.args[0], pos),)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                e.args = (self._add_line_info(None, pos),)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def _repr(self, value, pos):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        __traceback_hide__ = True

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        try:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if value is None:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                return ""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if self._unicode:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                try:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    value = str(value)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                except UnicodeDecodeError:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    value = bytes(value)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if not isinstance(value, basestring_):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    value = coerce_text(value)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if isinstance(value, str) and self.default_encoding:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    value = value.encode(self.default_encoding)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        except Exception as e:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            e.args = (self._add_line_info(e.args[0], pos),)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if self._unicode and isinstance(value, bytes):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if not self.default_encoding:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    raise UnicodeDecodeError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        "Cannot decode bytes value %r into unicode "

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        "(no default_encoding provided)" % value

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                try:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    value = value.decode(self.default_encoding)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                except UnicodeDecodeError as e:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    raise UnicodeDecodeError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        e.encoding,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        e.object,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        e.start,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        e.end,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        e.reason + " in string %r" % value,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            elif not self._unicode and isinstance(value, str):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if not self.default_encoding:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    raise UnicodeEncodeError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        "Cannot encode unicode value %r into bytes "

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        "(no default_encoding provided)" % value

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                value = value.encode(self.default_encoding)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return value

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def _add_line_info(self, msg, pos):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        msg = "%s at line %s column %s" % (msg, pos[0], pos[1])

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if self.name:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            msg += " in file %s" % self.name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return msg

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def sub(content, delimiters=None, **kw):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    name = kw.get("__name")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    tmpl = Template(content, name=name, delimiters=delimiters)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return tmpl.substitute(kw)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def paste_script_template_renderer(content, vars, filename=None):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    tmpl = Template(content, name=filename)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return tmpl.substitute(vars)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
class bunch(dict):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __init__(self, **kw):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        for name, value in kw.items():

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            setattr(self, name, value)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __setattr__(self, name, value):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self[name] = value

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __getattr__(self, name):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        try:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return self[name]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        except KeyError:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise AttributeError(name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __getitem__(self, key):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if "default" in self:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            try:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                return dict.__getitem__(self, key)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            except KeyError:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                return dict.__getitem__(self, "default")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return dict.__getitem__(self, key)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __repr__(self):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return "<%s %s>" % (

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self.__class__.__name__,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            " ".join(["%s=%r" % (k, v) for k, v in sorted(self.items())]),

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
class TemplateDef:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __init__(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self, template, func_name, func_signature, body, ns, pos, bound_self=None

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    ):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self._template = template

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self._func_name = func_name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self._func_signature = func_signature

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self._body = body

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self._ns = ns

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self._pos = pos

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self._bound_self = bound_self

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __repr__(self):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return "<tempita function %s(%s) at %s:%s>" % (

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._func_name,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._func_signature,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._template.name,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._pos,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __str__(self):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return self()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __call__(self, *args, **kw):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        values = self._parse_signature(args, kw)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ns = self._ns.copy()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ns.update(values)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if self._bound_self is not None:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ns["self"] = self._bound_self

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        out = []

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        subdefs = {}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self._template._interpret_codes(self._body, ns, out, subdefs)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return "".join(out)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __get__(self, obj, type=None):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if obj is None:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return self

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return self.__class__(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._template,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._func_name,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._func_signature,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._body,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._ns,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            self._pos,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            bound_self=obj,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def _parse_signature(self, args, kw):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        values = {}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        sig_args, var_args, var_kw, defaults = self._func_signature

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        extra_kw = {}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        for name, value in kw.items():

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if not var_kw and name not in sig_args:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                raise TypeError("Unexpected argument %s" % name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if name in sig_args:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                values[sig_args] = value

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                extra_kw[name] = value

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        args = list(args)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        sig_args = list(sig_args)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        while args:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            while sig_args and sig_args[0] in values:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                sig_args.pop(0)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if sig_args:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                name = sig_args.pop(0)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                values[name] = args.pop(0)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            elif var_args:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                values[var_args] = tuple(args)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                break

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                raise TypeError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    "Extra position arguments: %s" % ", ".join([repr(v) for v in args])

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        for name, value_expr in defaults.items():

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if name not in values:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                values[name] = self._template._eval(value_expr, self._ns, self._pos)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        for name in sig_args:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if name not in values:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                raise TypeError("Missing argument: %s" % name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if var_kw:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            values[var_kw] = extra_kw

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return values

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
class TemplateObject:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __init__(self, name):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self.__name = name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self.get = TemplateObjectGetter(self)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __repr__(self):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return "<%s %s>" % (self.__class__.__name__, self.__name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
class TemplateObjectGetter:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __init__(self, template_obj):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        self.__template_obj = template_obj

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __getattr__(self, attr):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return getattr(self.__template_obj, attr, Empty)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __repr__(self):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return "<%s around %r>" % (self.__class__.__name__, self.__template_obj)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
class _Empty:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __call__(self, *args, **kw):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return self

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __str__(self):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return ""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __repr__(self):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return "Empty"

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __unicode__(self):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return ""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __iter__(self):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return iter(())

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def __bool__(self):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return False

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
Empty = _Empty()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
del _Empty

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
############################################################

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
## Lexing and Parsing

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
############################################################

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def lex(s, name=None, trim_whitespace=True, line_offset=0, delimiters=None):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    """

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    Lex a string into chunks:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> lex('hey')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ['hey']

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> lex('hey {{you}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ['hey ', ('you', (1, 7))]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> lex('hey {{')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        Traceback (most recent call last):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ...

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        TemplateError: No }} to finish last expression at line 1 column 7

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> lex('hey }}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        Traceback (most recent call last):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ...

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        TemplateError: }} outside expression at line 1 column 7

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> lex('hey {{ {{')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        Traceback (most recent call last):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ...

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        TemplateError: {{ inside expression at line 1 column 10

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    """

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if delimiters is None:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        delimiters = (

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            Template.default_namespace["start_braces"],

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            Template.default_namespace["end_braces"],

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    in_expr = False

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    chunks = []

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    last = 0

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    last_pos = (line_offset + 1, 1)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    token_re = re.compile(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        r"%s|%s" % (re.escape(delimiters[0]), re.escape(delimiters[1]))

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    for match in token_re.finditer(s):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        expr = match.group(0)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        pos = find_position(s, match.end(), last, last_pos)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if expr == delimiters[0] and in_expr:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                "%s inside expression" % delimiters[0], position=pos, name=name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        elif expr == delimiters[1] and not in_expr:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                "%s outside expression" % delimiters[1], position=pos, name=name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if expr == delimiters[0]:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            part = s[last:match.start()]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if part:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                chunks.append(part)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            in_expr = True

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            chunks.append((s[last: match.start()], last_pos))

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            in_expr = False

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        last = match.end()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        last_pos = pos

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if in_expr:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            "No %s to finish last expression" % delimiters[1],

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            name=name,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            position=last_pos,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    part = s[last:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if part:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        chunks.append(part)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if trim_whitespace:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        chunks = trim_lex(chunks)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return chunks

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
statement_re = re.compile(r"^(?:if |elif |for |def |inherit |default |py:)")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
single_statements = ["else", "endif", "endfor", "enddef", "continue", "break"]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
trail_whitespace_re = re.compile(r"\n\r?[\t ]*$")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
lead_whitespace_re = re.compile(r"^[\t ]*\n")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def trim_lex(tokens):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    r"""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    Takes a lexed set of tokens, and removes whitespace when there is

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    a directive on a line by itself:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
       >>> tokens = lex('{{if x}}\nx\n{{endif}}\ny', trim_whitespace=False)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
       >>> tokens

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
       [('if x', (1, 3)), '\nx\n', ('endif', (3, 3)), '\ny']

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
       >>> trim_lex(tokens)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
       [('if x', (1, 3)), 'x\n', ('endif', (3, 3)), 'y']

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    """

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    last_trim = None

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    for i, current in enumerate(tokens):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if isinstance(current, basestring_):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            # we don't trim this

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            continue

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        item = current[0]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if not statement_re.search(item) and item not in single_statements:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            continue

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if not i:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            prev = ""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            prev = tokens[i - 1]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if i + 1 >= len(tokens):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            next_chunk = ""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            next_chunk = tokens[i + 1]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if not isinstance(next_chunk, basestring_) or not isinstance(prev, basestring_):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            continue

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        prev_ok = not prev or trail_whitespace_re.search(prev)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if i == 1 and not prev.strip():

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            prev_ok = True

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if last_trim is not None and last_trim + 2 == i and not prev.strip():

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            prev_ok = "last"

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if prev_ok and (

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            not next_chunk

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            or lead_whitespace_re.search(next_chunk)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            or (i == len(tokens) - 2 and not next_chunk.strip())

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if prev:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if (i == 1 and not prev.strip()) or prev_ok == "last":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    tokens[i - 1] = ""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    m = trail_whitespace_re.search(prev)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    # +1 to leave the leading \n on:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    prev = prev[: m.start() + 1]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    tokens[i - 1] = prev

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if next_chunk:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                last_trim = i

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if i == len(tokens) - 2 and not next_chunk.strip():

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    tokens[i + 1] = ""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    m = lead_whitespace_re.search(next_chunk)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    next_chunk = next_chunk[m.end():]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    tokens[i + 1] = next_chunk

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return tokens

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def find_position(string, index, last_index, last_pos):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    """Given a string and index, return (line, column)"""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    lines = string.count("\n", last_index, index)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if lines > 0:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        column = index - string.rfind("\n", last_index, index)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        column = last_pos[1] + (index - last_index)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return (last_pos[0] + lines, column)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def parse(s, name=None, line_offset=0, delimiters=None):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    r"""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    Parses a string into a kind of AST

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('{{x}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        [('expr', (1, 3), 'x')]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('foo')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ['foo']

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('{{if x}}test{{endif}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        [('cond', (1, 3), ('if', (1, 3), 'x', ['test']))]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('series->{{for x in y}}x={{x}}{{endfor}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ['series->', ('for', (1, 11), ('x',), 'y', ['x=', ('expr', (1, 27), 'x')])]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('{{for x, y in z:}}{{continue}}{{endfor}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        [('for', (1, 3), ('x', 'y'), 'z', [('continue', (1, 21))])]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('{{py:x=1}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        [('py', (1, 3), 'x=1')]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('{{if x}}a{{elif y}}b{{else}}c{{endif}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        [('cond', (1, 3), ('if', (1, 3), 'x', ['a']), ('elif', (1, 12), 'y', ['b']), ('else', (1, 23), None, ['c']))]  # noqa: E501

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    Some exceptions::

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('{{continue}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        Traceback (most recent call last):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ...

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        TemplateError: continue outside of for loop at line 1 column 3

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('{{if x}}foo')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        Traceback (most recent call last):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ...

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        TemplateError: No {{endif}} at line 1 column 3

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('{{else}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        Traceback (most recent call last):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ...

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        TemplateError: else outside of an if block at line 1 column 3

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('{{if x}}{{for x in y}}{{endif}}{{endfor}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        Traceback (most recent call last):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ...

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        TemplateError: Unexpected endif at line 1 column 25

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('{{if}}{{endif}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        Traceback (most recent call last):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ...

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        TemplateError: if with no expression at line 1 column 3

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('{{for x y}}{{endfor}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        Traceback (most recent call last):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ...

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        TemplateError: Bad for (no "in") in 'x y' at line 1 column 3

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        >>> parse('{{py:x=1\ny=2}}')

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        Traceback (most recent call last):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            ...

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        TemplateError: Multi-line py blocks must start with a newline at line 1 column 3

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    """

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if delimiters is None:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        delimiters = (

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            Template.default_namespace["start_braces"],

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            Template.default_namespace["end_braces"],

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    tokens = lex(s, name=name, line_offset=line_offset, delimiters=delimiters)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    result = []

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    while tokens:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        next_chunk, tokens = parse_expr(tokens, name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        result.append(next_chunk)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return result

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def parse_expr(tokens, name, context=()):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if isinstance(tokens[0], basestring_):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return tokens[0], tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    expr, pos = tokens[0]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    expr = expr.strip()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if expr.startswith("py:"):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        expr = expr[3:].lstrip(" \t")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if expr.startswith(("\n", "\r")):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            expr = expr.lstrip("\r\n")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if "\r" in expr:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                expr = expr.replace("\r\n", "\n")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                expr = expr.replace("\r", "")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            expr += "\n"

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        elif "\n" in expr:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                "Multi-line py blocks must start with a newline",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                position=pos,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                name=name,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return ("py", pos, expr), tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif expr in ("continue", "break"):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if "for" not in context:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise TemplateError("continue outside of for loop", position=pos, name=name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return (expr, pos), tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif expr.startswith("if "):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return parse_cond(tokens, name, context)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif expr.startswith("elif ") or expr == "else":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            "%s outside of an if block" % expr.split()[0], position=pos, name=name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif expr in ("if", "elif", "for"):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        raise TemplateError("%s with no expression" % expr, position=pos, name=name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif expr in ("endif", "endfor", "enddef"):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        raise TemplateError("Unexpected %s" % expr, position=pos, name=name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif expr.startswith("for "):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return parse_for(tokens, name, context)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif expr.startswith("default "):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return parse_default(tokens, name, context)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif expr.startswith("inherit "):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return parse_inherit(tokens, name, context)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif expr.startswith("def "):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return parse_def(tokens, name, context)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif expr.startswith("#"):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return ("comment", pos, tokens[0][0]), tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return ("expr", pos, tokens[0][0]), tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def parse_cond(tokens, name, context):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    start = tokens[0][1]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    pieces = []

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    context = context + ("if",)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    while 1:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if not tokens:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise TemplateError("Missing {{endif}}", position=start, name=name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if isinstance(tokens[0], tuple) and tokens[0][0] == "endif":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return ("cond", start) + tuple(pieces), tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        next_chunk, tokens = parse_one_cond(tokens, name, context)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        pieces.append(next_chunk)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def parse_one_cond(tokens, name, context):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    (first, pos), tokens = tokens[0], tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    content = []

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    first = first.removesuffix(":")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if first.startswith("if "):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        part = ("if", pos, first[3:].lstrip(), content)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif first.startswith("elif "):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        part = ("elif", pos, first[5:].lstrip(), content)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif first == "else":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        part = ("else", pos, None, content)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        assert 0, "Unexpected token %r at %s" % (first, pos)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    while 1:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if not tokens:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise TemplateError("No {{endif}}", position=pos, name=name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if isinstance(tokens[0], tuple) and (

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            tokens[0][0] == "endif"

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            or tokens[0][0].startswith("elif ")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            or tokens[0][0] == "else"

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return part, tokens

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        next_chunk, tokens = parse_expr(tokens, name, context)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        content.append(next_chunk)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def parse_for(tokens, name, context):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    first, pos = tokens[0]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    tokens = tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    context = ("for",) + context

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    content = []

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    assert first.startswith("for "), first

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    first = first.removesuffix(":")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    first = first[3:].strip()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    match = in_re.search(first)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if not match:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        raise TemplateError('Bad for (no "in") in %r' % first, position=pos, name=name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    vars = first[: match.start()]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if "(" in vars:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            "You cannot have () in the variable section of a for loop (%r)" % vars,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            position=pos,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            name=name,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    vars = tuple(v.strip() for v in first[: match.start()].split(",") if v.strip())

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    expr = first[match.end():]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    while 1:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if not tokens:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise TemplateError("No {{endfor}}", position=pos, name=name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if isinstance(tokens[0], tuple) and tokens[0][0] == "endfor":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return ("for", pos, vars, expr, content), tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        next_chunk, tokens = parse_expr(tokens, name, context)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        content.append(next_chunk)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def parse_default(tokens, name, context):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    first, pos = tokens[0]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    assert first.startswith("default ")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    first = first.split(None, 1)[1]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    parts = first.split("=", 1)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if len(parts) == 1:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            "Expression must be {{default var=value}}; no = found in %r" % first,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            position=pos,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            name=name,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    var = parts[0].strip()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if "," in var:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            "{{default x, y = ...}} is not supported", position=pos, name=name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if not var_re.search(var):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            "Not a valid variable name for {{default}}: %r" % var,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            position=pos,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            name=name,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    expr = parts[1].strip()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return ("default", pos, var, expr), tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def parse_inherit(tokens, name, context):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    first, pos = tokens[0]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    assert first.startswith("inherit ")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    expr = first.split(None, 1)[1]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return ("inherit", pos, expr), tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def parse_def(tokens, name, context):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    first, start = tokens[0]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    tokens = tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    assert first.startswith("def ")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    first = first.split(None, 1)[1]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    first = first.removesuffix(":")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if "(" not in first:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        func_name = first

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        sig = ((), None, None, {})

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    elif not first.endswith(")"):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            "Function definition doesn't end with ): %s" % first,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            position=start,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            name=name,

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        first = first[:-1]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        func_name, sig_text = first.split("(", 1)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        sig = parse_signature(sig_text, name, start)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    context = context + ("def",)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    content = []

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    while 1:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if not tokens:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise TemplateError("Missing {{enddef}}", position=start, name=name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if isinstance(tokens[0], tuple) and tokens[0][0] == "enddef":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return ("def", start, func_name, sig, content), tokens[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        next_chunk, tokens = parse_expr(tokens, name, context)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        content.append(next_chunk)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def parse_signature(sig_text, name, pos):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    tokens = tokenize.generate_tokens(StringIO(sig_text).readline)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    sig_args = []

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    var_arg = None

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    var_kw = None

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    defaults = {}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    def get_token(pos=False):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        try:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            tok_type, tok_string, (srow, scol), (erow, ecol), line = next(tokens)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        except StopIteration:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return tokenize.ENDMARKER, ""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if pos:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return tok_type, tok_string, (srow, scol), (erow, ecol)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            return tok_type, tok_string

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    while 1:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        var_arg_type = None

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        tok_type, tok_string = get_token()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if tok_type == tokenize.ENDMARKER:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            break

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if tok_type == tokenize.OP and tok_string in {"*", "**"}:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            var_arg_type = tok_string

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            tok_type, tok_string = get_token()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if tok_type != tokenize.NAME:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                "Invalid signature: (%s)" % sig_text, position=pos, name=name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        var_name = tok_string

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        tok_type, tok_string = get_token()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if tok_type == tokenize.ENDMARKER or (

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            tok_type == tokenize.OP and tok_string == ","

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        ):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if var_arg_type == "*":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                var_arg = var_name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            elif var_arg_type == "**":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                var_kw = var_name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                sig_args.append(var_name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            if tok_type == tokenize.ENDMARKER:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                break

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            continue

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if var_arg_type is not None:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                "Invalid signature: (%s)" % sig_text, position=pos, name=name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if tok_type == tokenize.OP and tok_string == "=":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            nest_type = None

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            unnest_type = None

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            nest_count = 0

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            start_pos = end_pos = None

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            parts = []

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            while 1:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                tok_type, tok_string, s, e = get_token(True)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if start_pos is None:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    start_pos = s

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                end_pos = e

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if tok_type == tokenize.ENDMARKER and nest_count:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    raise TemplateError(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        "Invalid signature: (%s)" % sig_text, position=pos, name=name

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if not nest_count and (

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    tok_type == tokenize.ENDMARKER

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    or (tok_type == tokenize.OP and tok_string == ",")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                ):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    default_expr = isolate_expression(sig_text, start_pos, end_pos)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    defaults[var_name] = default_expr

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    sig_args.append(var_name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    break

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                parts.append((tok_type, tok_string))

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                if nest_count and tok_type == tokenize.OP and tok_string == nest_type:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    nest_count += 1

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                elif (

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    nest_count and tok_type == tokenize.OP and tok_string == unnest_type

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                ):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    nest_count -= 1

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    if not nest_count:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                        nest_type = unnest_type = None

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                elif (

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    not nest_count

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    and tok_type == tokenize.OP

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    and tok_string in ("(", "[", "{")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                ):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    nest_type = tok_string

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    nest_count = 1

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
                    unnest_type = {"(": ")", "[": "]", "{": "}"}[nest_type]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return sig_args, var_arg, var_kw, defaults

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def isolate_expression(string, start_pos, end_pos):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    srow, scol = start_pos

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    srow -= 1

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    erow, ecol = end_pos

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    erow -= 1

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    lines = string.splitlines(True)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if srow == erow:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        return lines[srow][scol:ecol]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    parts = [lines[srow][scol:]]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    parts.extend(lines[srow + 1:erow])

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if erow < len(lines):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        # It'll sometimes give (end_row_past_finish, 0)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        parts.append(lines[erow][:ecol])

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    return "".join(parts)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
_fill_command_usage = """\

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
%prog [OPTIONS] TEMPLATE arg=value

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
Use py:arg=value to set a Python value; otherwise all values are

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
strings.

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
"""

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
def fill_command(args=None):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    import sys

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    import optparse

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    import pkg_resources

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    import os

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if args is None:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        args = sys.argv[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    dist = pkg_resources.get_distribution("Paste")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    parser = optparse.OptionParser(version=coerce_text(dist), usage=_fill_command_usage)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    parser.add_option(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        "-o",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        "--output",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        dest="output",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        metavar="FILENAME",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        help="File to write output to (default stdout)",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    parser.add_option(

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        "--env",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        dest="use_env",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        action="store_true",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        help="Put the environment in as top-level variables",

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    )

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    options, args = parser.parse_args(args)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if len(args) < 1:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        print("You must give a template filename")

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        sys.exit(2)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    template_name = args[0]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    args = args[1:]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    vars = {}

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if options.use_env:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        vars.update(os.environ)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    for value in args:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if "=" not in value:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            print("Bad argument: %r" % value)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            sys.exit(2)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        name, value = value.split("=", 1)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        if name.startswith("py:"):

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            name = name[:3]

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            value = eval(value)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        vars[name] = value

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if template_name == "-":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        template_content = sys.stdin.read()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        template_name = "<stdin>"

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        with open(template_name, "rb") as f:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            template_content = f.read()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    template = Template(template_content, name=template_name)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    result = template.substitute(vars)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    if options.output:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        with open(options.output, "wb") as f:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
            f.write(result)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    else:

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
        sys.stdout.write(result)

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")


    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
if __name__ == "__main__":

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
    fill_command()

    def _safe_eval(self, expr, context):
        """Safely evaluate an expression in the given context.
        This method is used as a safer alternative to eval().
        """
        # If the expression is a simple variable name, just look it up in the context
        if isinstance(expr, str) and expr.isidentifier() and expr in context:
            return context[expr]
        
        # For more complex expressions, we need to be careful
        # First, check if it's a literal that can be safely evaluated
        try:
            return ast.literal_eval(expr)
        except (ValueError, SyntaxError):
            pass
        
        # If it's not a literal, we need to restrict what can be evaluated
        # This is still risky, but better than raw eval()
        # Create a restricted globals dictionary with only safe functions
        safe_globals = {
            '__builtins__': {
                name: getattr(__builtins__, name)
                for name in ['abs', 'all', 'any', 'bool', 'dict', 'enumerate', 
                            'filter', 'float', 'format', 'frozenset', 'int', 
                            'isinstance', 'len', 'list', 'map', 'max', 'min', 
                            'range', 'repr', 'reversed', 'round', 'set', 'slice', 
                            'sorted', 'str', 'sum', 'tuple', 'zip']
            }
        }
        
        # Merge with the provided context
        safe_globals.update(context)
        
        # Use compile to check syntax first
        try:
            code = compile(expr, '<string>', 'eval')
            return eval(code, safe_globals, {})
        except Exception as e:
            raise ValueError(f"Error evaluating expression {expr!r}: {e}")
